<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>波比日记</title>
      <link href="/post/%E6%B3%A2%E6%AF%94%E6%97%A5%E8%AE%B0.html"/>
      <url>/post/%E6%B3%A2%E6%AF%94%E6%97%A5%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p>波比: 哥，你说的金币是什么啊<br>我: 就是钱<br>波比: 哥，那挣金币很容易吗?<br>我: 容易<br>波比: 那你第一的时候能带我玩吗<br>我: 看心情<br>波比: 噢噢，那哥，你为什么选我啊，是因为我伤害高吗<br>我: 因为你便宜，过渡用<br>波比: 肯定是因为我伤害高<br>我: 因为黑夜里，你能给我带来一些安全感<br>波比很开心: 就知道哥最喜欢我了</p><p><img src="../images/波比日记/dbdfdf1dbf5fef84a67d815a53f0eb88.png" style="zoom:50%;" /></p><p>波比: 哥，为什么我总是在前面啊，我也想上后面去。<br>我: 你打不到那么远，你就在前面站着吧<br>波比: 好吧，只要哥开心就好</p><p><img src="../images/波比日记/6bce7dc291cd732c95df6ef5ab0cb717.png" style="zoom:50%;" /></p><p>波比: 哥，我害怕，好像有很多人朝我这来了</p><p><strong>我没说话</strong></p><p>波比: 哥你还在吗，你可以帮帮我吗，在我前面放一个五费大哥替我挡一下</p><p><strong>我没说话</strong></p><p>波比: 对面人好多啊哥，我快坚持不住了，哥你能救救我吗</p><p><strong>波比死了</strong></p><p><img src="../images/波比日记/3fefbba219255796cd7af61355ad7e77.png" style="zoom:50%;" /></p><p><strong>后来我在波比的日记里面看到</strong><br>我知道哥不喜欢我，我只是个便宜的倒贴货罢了，可是我不敢说，我怕说了哥就不要我了，我既没有三星四费的舒适感，也没有三星五费那么高的伤害，我身上的每一点哥都不喜欢，哥只是想让我去前面等死，给其他大哥们多争取一点时间。但是哥，我也想要你对我好，我也想让你在我前面放一个五费大哥替我抗伤害。可是我知道，我不配…</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 波比 </tag>
            
            <tag> 联盟战棋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么？你给我念了一圈菜谱只为了教我油焖大虾？</title>
      <link href="/post/%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E7%BB%99%E6%88%91%E5%BF%B5%E4%BA%86%E4%B8%80%E5%9C%88%E8%8F%9C%E8%B0%B1%E5%8F%AA%E4%B8%BA%E4%BA%86%E6%95%99%E6%88%91%E6%B2%B9%E7%84%96%E5%A4%A7%E8%99%BE%EF%BC%9F.html"/>
      <url>/post/%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E7%BB%99%E6%88%91%E5%BF%B5%E4%BA%86%E4%B8%80%E5%9C%88%E8%8F%9C%E8%B0%B1%E5%8F%AA%E4%B8%BA%E4%BA%86%E6%95%99%E6%88%91%E6%B2%B9%E7%84%96%E5%A4%A7%E8%99%BE%EF%BC%9F.html</url>
      
        <content type="html"><![CDATA[<p>夜色正浓</p><p>龙大侠刚从温泉中沐浴更衣，耳边突然响起一阵狂笑：啊哈哈哈哈哈，追了你三天三夜，总算是查到你的行踪，今天我就要挑断你的筋</p><p>龙大侠斜目观瞧，轻蔑一笑：我当是谁，原来是菜籽派的走狗史用游啊，说罢拿起酒杯慢慢品味起来</p><p>面相蜡黄的史用游上前一步：哼，姓龙的我看你今天往哪儿跑，说罢双手一拍，瞬间从四面八方跑出了众多喽啰兵，皆持兵刃将龙大侠所坐之地围的是水泄不通</p><p>龙大侠微闭双眼，将酒杯放在鼻下闻了闻，不屑的说道：就凭你们这些葱姜蒜瓣也想抓我？说完单掌击出，瞬间将一蒜兵轰成蒜沫，看不出完整样子，又一掌击出，将不远处的葱兵吸到掌心，只听得嘎巴一声，葱兵身首分离，整个过程行云流水一气呵成，龙大侠甚至没有挪动位置便轻易将二人虐杀</p><p>龙大侠将手里的葱头甩到人群中哈哈一笑，继续品起酒来，惨死的蒜兵和葱兵身体里不住流出的液体混合在一起，形成刺鼻的气味隐隐弥漫，众喽啰兵一时被眼前惨相惊住，竟无一人敢向前</p><p>史用游没想到龙大侠的手段居然如此残忍，心中略微胆寒，迅速稳定情绪后，猛踏一步，借势一拳轰出，直冲龙大侠胸口而来</p><p>龙大侠面色微动，仅听拳风便知这一拳的威力，急忙双掌护住胸口，硬生生接住这一拳，可对方力量过于霸道，龙大侠居然整个人被震飞到温泉里，一个踉跄，才勉强稳住身形</p><p>史用游一摆手众葱姜蒜喽啰一拥而上，纷纷举起武器，誓要把龙大侠砍成虾泥，龙大侠左突右挡，虽然每一拳便能带走一条葱姜蒜的性命，可无奈对方人数众多，龙大侠压力倍增，渐渐面皮开始变的通红，鬓角也渗出汗来，看似是逐渐力竭</p><p>史用游微眯双眼，瞅准时机，从人群的空挡中轰出一掌，正中龙大侠胸口，突如其来的变故让龙大侠口吐鲜血，身体瞬间被轰飞出五米，在撞碎一堵矮墙后才堪堪停下</p><p>龙大侠抹了一把嘴边的鲜血，用劲全身力气才吐出几个字：居然是史家绝学，高温掌，终于是被你练到了第 9 层，好好好，说罢便双眼一黑没了呼吸，饮恨而终</p><p>史用游轻蔑一笑到：小的们，给我把他的头砍下来示众！</p><p>等一下等一下，你给我讲的是什么东西啊，小苗一脸疑惑的问我</p><p>我挑了挑眉，睡前故事啊，还能是什么，小苗问我：你管这个叫睡前故事？我把书合上说：对啊，小时候我爸就给我讲这些故事</p><p>小苗从床上坐起来一把抢过我的书，看了一眼封皮：这不是你随身携带的破菜谱么？我把书抢过来说：什么破菜谱，是祖传的菜谱</p><p>小苗说道：感情刚才你给我念的是菜谱？那什么龙大侠啊，史用游，葱姜蒜，高温掌都是什么啊？</p><p>我笑嘻嘻的说道：就是大龙虾，食用油，葱姜蒜，和油温咯，说完从祖传的菜谱里翻到了油焖大虾这道菜：我来给你翻译翻译</p><hr><p>【备料】</p><p>新疆养殖的龙虾一斤，挑掉虾线备用</p><p>红烧酱油一瓶盖</p><p>味极鲜一瓶盖</p><p>料酒一瓶盖</p><p>耗油一瓶盖</p><p>蒸鱼豆豉一瓶盖</p><p>葱姜蒜切沫备用</p><hr><p>【虾】</p><ol><li><p>将准备好的龙虾洗净，倒入料酒腌制五分钟<br><img src="\images\什么？你给我念了一圈菜谱只为了教我油焖大虾？\4cb649a026c9adb9fecd639ee7a37422.png" alt=""></p><p><img src="\images\什么？你给我念了一圈菜谱只为了教我油焖大虾？\ac6cacf86e82c659009b2e5b8da6696a.png" alt=""></p></li></ol><p>【爆炒】</p><ol><li><p>起过烧油，油温升高后转小火，将龙虾倒入油锅两面煎炸，直至变为红色，倒入葱姜蒜末，翻炒一会儿，倒入味极鲜，耗油，蒸鱼豆豉，红烧酱油，翻炒一分钟，出锅开造<br><img src="\images\什么？你给我念了一圈菜谱只为了教我油焖大虾？\cb6f22f41ee04e76142dc87096e9c949.png" alt=""></p><p><img src="\images\什么？你给我念了一圈菜谱只为了教我油焖大虾？\0f96a5604276fdf43824c8f9ce0500a5.png" alt=""><br><img src="\images\什么？你给我念了一圈菜谱只为了教我油焖大虾？\12649819250e72fd0eba4d4753451d5b.png" alt=""></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 菜谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么一个字写很多遍、越写就越陌生</title>
      <link href="/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E5%AD%97%E5%86%99%E5%BE%88%E5%A4%9A%E9%81%8D%E3%80%81%E8%B6%8A%E5%86%99%E5%B0%B1%E8%B6%8A%E9%99%8C%E7%94%9F.html"/>
      <url>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E5%AD%97%E5%86%99%E5%BE%88%E5%A4%9A%E9%81%8D%E3%80%81%E8%B6%8A%E5%86%99%E5%B0%B1%E8%B6%8A%E9%99%8C%E7%94%9F.html</url>
      
        <content type="html"><![CDATA[<p>你曾经被罚抄书 100 遍吗<sup><a href="#fn_1" id="reffn_1">1</a></sup>？越抄字越怪，越抄它们越不像汉字</p><p>似曾相识（Déjà Vu）的感觉大家都遇到过，明明从来没见过，看到了却觉得曾经见过。现在科学家研究了与 “似曾相识” 相反、更神秘的 “从未见过” 现象（jamais vu） </p><p>最常见的例子跟被罚抄书的体验类似，如果你盯着看这么多个 “我”，越看就越觉得这些字变成了陌生的汉字、甚至陌生的抽象图形，反正越看越不像 “我” </p><p>科学家对此解释是大脑会避免饱和，我们的认知系统必须保持灵活性，使我们能够将注意力转移到需要的地方，而不是在重复性任务中迷失太久<sup><a href="#fn_2" id="reffn_2">2</a></sup> 这项研究获得了今年的搞笑诺贝尔文学奖</p><p><a href="https://www.sciencealert.com/the-opposite-of-dj-vu-exists-and-its-even-more-uncanny">The Opposite of Déjà Vu Exists, And It‘s Even More Uncanny</a></p><blockquote id="fn_1"><sup>1</sup>. 这属于体罚，不符合文明社会的基本标准<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 人的大脑特别容易疲劳（麻木），产品设计里有一个分支，重点就是避免 “熟视无睹”、“视而不见” 这些大脑疲劳的情况。比如高速公路应该避免很长的直路，以防止司机大脑疲劳、麻痹大意。我没研究过，我猜 “从未见过” 现象（jamais vu）跟这方面的设计思路有关<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 有趣的事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK21 真的来了：虚拟线程正式发布及十多项新特性！</title>
      <link href="/post/JDK21%20%E7%9C%9F%E7%9A%84%E6%9D%A5%E4%BA%86%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%8F%8A%E5%8D%81%E5%A4%9A%E9%A1%B9%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81.html"/>
      <url>/post/JDK21%20%E7%9C%9F%E7%9A%84%E6%9D%A5%E4%BA%86%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%8F%8A%E5%8D%81%E5%A4%9A%E9%A1%B9%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>万事万物都经不起审视，因为世上没有同样的成长环境，也没有同样的认知水平，更<strong>「没有适用于所有人的解决方案」</strong>；</p><p>不要急着评判文章列出的观点，只需代入其中，适度审视一番自己即可，能<strong>「跳脱出来从外人的角度看看现在的自己处在什么样的阶段」才不为俗人</strong>。</p><p>怎么想、怎么做，全在乎自己<strong>「不断实践中寻找适合自己的大道」</strong></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>Java 21 进入发布候选阶段，其中包括 15 个最终特性，包括虚拟线程、分代 Z 垃圾收集器和密钥封装机制 API。</p><p>JDK21 计划于 9 月 19 日作为 Oracle 标准 Java 实现的下一个 LTS 版本发布，已进入发布候选 (RC) 阶段。Java 21 将具有 15 个新特性，之前提议的第 16 个特性实验性 Shenandoah 垃圾收集器已在 6 月被舍弃。</p><p>进入终版的 15 个特性涵盖从字符串模板和结构化并发预览，到虚拟线程和密钥封装机制 (KEM) API 等。JDK 21 于 7 月 20 日进入了第二阶段渐进开发，在 6 月 8 日首次渐进开发后。发布候选阶段从 8 月 10 日开始，与第二阶段渐进开发同时进行。第二个 RC 定于 8 月 24 日发布。Oracle 每 6 个月发布一次标准 Java 新版本，最近的 JDK 20 于 2022 年 3 月 21 日发布。</p><h2 id="2-JDK-21-的具体提案"><a href="#2-JDK-21-的具体提案" class="headerlink" title="2 JDK 21 的具体提案"></a>2 JDK 21 的具体提案</h2><h3 id="2-1-结构化并发（预览）"><a href="#2-1-结构化并发（预览）" class="headerlink" title="2.1 结构化并发（预览）"></a>2.1 结构化并发（预览）</h3><p>通过结构化并发 API 简化了并发编程，将运行在不同线程中的相关任务组视为一个工作单元。这简化了错误处理和取消，提高了可靠性并增强了可观察性。</p><p>结构化并发在 JDK 20 和 JDK 19 (2022 年 3 月、9 月发布) 中进行孵化；它将以预览 API 形式出现在 JUC 包。这次唯一显著的变化是 StructuredTaskScope::Fork (…) 方法返回一个 [Subtask] 而不是 Future。</p><p>结构化并发的目标包括促进一种并发编程风格，可以消除取消和关闭时常见的风险，如线程泄漏和取消延迟，并提高并发代码的可观察性。</p><h3 id="2-2-作用域值"><a href="#2-2-作用域值" class="headerlink" title="2.2 作用域值"></a>2.2 作用域值</h3><p>也处于预览状态，将使线程内外能够共享不可变数据。与线程本地变量相比，它们是首选，尤其是在使用大量虚拟线程时。</p><p>线程本地变量具有设计缺陷，包括不受约束的可变性、无边界的生命周期和昂贵的继承。作用域值允许庞大程序中的组件安全地共享数据，而无需使用方法参数。该提案在 JDK 20 中进行了孵化。该计划的目标包括易用性、可理解性、健壮性和性能。</p><h3 id="2-3-禁止动态加载代理"><a href="#2-3-禁止动态加载代理" class="headerlink" title="2.3 禁止动态加载代理"></a>2.3 禁止动态加载代理</h3><p>一项准备禁止动态加载代理的提议要求，在向运行中的 JVM 动态加载代理时发出警告。这些警告旨在为将来的版本做准备，以默认禁止动态加载代理，以提高完整性。该提案的其他目标包括重新评估：</p><ul><li>可维护性 (涉及对运行代码的特殊修改)</li><li>完整性 (假设运行代码不会任意更改)</li></ul><p>之间的平衡，并确保大多数不需要动态加载代理的工具不受影响。该计划还要求将动态加载代理的能力与 “超能力” 功能 (如深度反射) 保持一致。代理是一种组件，可在应用程序运行时改变应用程序代码。这些组件由 2004 年 JDK 5 中的 Java 平台分析架构引入，作为一种让工具 (特别是分析器) 检测类的方法。尽管代理是为良性检测设计的，但高级开发人员发现了一些用例，如面向切面编程可以任意方式改变应用程序行为。同样，没有什么能阻止代理改变 JDK 本身等代码。JDK 5 要求代理在命令行中指定，以确保应用程序所有者批准使用代理。在 JDK 21 中，计划要求像启动时加载代理一样，需要应用程序所有者批准动态加载代理。这一变化将 Java 平台进一步接近默认完整性。</p><h3 id="2-4-密钥封装机制-API"><a href="#2-4-密钥封装机制-API" class="headerlink" title="2.4 密钥封装机制 API"></a>2.4 密钥封装机制 API</h3><p>一种通过公钥密码学安全封装对称密钥的加密技术。该提案的一个目标是让应用程序能够使用：</p><ul><li>RSA 密钥封装机制 (RSA-KEM)</li><li>椭圆曲线集成加密方案 (ECIES) 等 KEM 算法</li><li>及美国国家标准与技术研究院 (NIST) 后量子密码学标准化过程的候选算法</li></ul><p>另一个目标是能在更高级别的协议 (如传输层安全协议 TLS) 和密码方案 (如混合公钥加密 HPKE) 中使用 KEM。安全提供者可以用 Java 或本机代码实现 KEM 算法，并包含 RFC 9180 中定义的 Diffie-Hellman KEM (DHKEM) 的实现。</p><h3 id="2-5-弃用-Windows-32-位-x86-端口"><a href="#2-5-弃用-Windows-32-位-x86-端口" class="headerlink" title="2.5 弃用 Windows 32 位 x86 端口"></a>2.5 弃用 Windows 32 位 x86 端口</h3><p>以便在未来版本中删除，目的是在未来的版本中删除该端口。该提案旨在更新构建系统，以便尝试为 Windows 32 位 x86 配置构建时发出错误消息。消息可以通过新的配置选项抑制。此外，该计划是将端口及相关的端口特定功能标记为已弃用以删除相关文档。该提案指出，支持 32 位操作的最后一个 Windows 操作系统 Windows 10 将于 2025 年 10 月结束生命周期。</p><h3 id="2-6-无名类和实例-main-方法预览"><a href="#2-6-无名类和实例-main-方法预览" class="headerlink" title="2.6 无名类和实例 main 方法预览"></a>2.6 无名类和实例 main 方法预览</h3><p>旨在使 Java 语言进化，以便学生在无需理解面向大型程序设计的语言特性的情况下编写第一个 Java 程序。学生可以为单类程序编写简化的声明，然后无缝地扩展程序以使用更高级的特性，而不是使用 Java 的单独方言。该提案不仅可以为 Java 提供平稳的入门，而且可以减少编写简单 Java 程序 (如脚本和命令行实用程序) 的麻烦。</p><h3 id="2-7-无名模式和变量的预览"><a href="#2-7-无名模式和变量的预览" class="headerlink" title="2.7 无名模式和变量的预览"></a>2.7 无名模式和变量的预览</h3><p>未命名模式匹配记录组件，而不声明组件的名称或类型，未命名变量可以初始化但不使用。两者都用下划线字符_表示。该提案旨在通过省略不必要的嵌套模式来改善记录模式的可读性，并通过识别必须声明但不会使用的变量来改善所有代码的可维护性。</p><h3 id="2-8-分代-ZGC"><a href="#2-8-分代-ZGC" class="headerlink" title="2.8 分代 ZGC"></a>2.8 分代 ZGC</h3><p>旨在通过为年轻对象和旧对象维护独立的代来改善应用程序性能。年轻对象往往很快就会死亡；维护独立的代将允许 ZGC 更频繁地收集年轻对象。运行在分代 ZGC 上的应用程序应会看到以下好处：分配中断风险更低，需要的堆内存开销更低，垃圾收集 CPU 开销更低。这些好处应该可以在吞吐量不明显下降的情况下实现。</p><h3 id="2-9-记录模式"><a href="#2-9-记录模式" class="headerlink" title="2.9 记录模式"></a>2.9 记录模式</h3><p>在 JDK 19 和 JDK 20 中进行了预览，用于解构记录值。记录模式和类型模式可以嵌套，以启用强大的、声明性的和可组合的数据导航和处理形式。该提案的目标包括扩展模式匹配以解构记录类的实例，添加嵌套模式以启用更可组合的数据查询。此特性与 switch 表达式和语句的模式匹配 (见下文) 共同演化。当前的 JEP 将在继续的经验和反馈的基础上通过进一步完善来最终确定该特性。除了少量编辑变化外，主要变化是删除了记录模式在增强的 for 语句标题中出现的支持。该特性可能会在未来的 JEP 中重新提出。</p><h3 id="2-10-switch-的模式匹配"><a href="#2-10-switch-的模式匹配" class="headerlink" title="2.10 switch 的模式匹配"></a>2.10 switch 的模式匹配</h3><p>使得 switch 表达式或语句可以针对许多模式进行测试，每个模式都有特定的操作，这样复杂的数据查询可以安全简洁地表达。该特性最初在 JDK 17 中提出，之后在 JDK 18、JDK 19 和 JDK 20 中进行了完善。它将在 JDK 21 中通过进一步的优化最终确定。与前面的 JEP 相比，主要变化是删除了带括号的模式并允许合格的 enum 常量，如带 switch 表达式和语句的常量。目标包括通过允许模式出现在 case 标签中来扩展 switch 表达式和语句的表达能力和适用范围，允许 switch 的历史 null 敌意在需要时得到放松，并通过要求模式 switch 语句覆盖所有潜在的输入值来增加 switch 语句的安全性。另一个目标是确保现有的 switch 表达式和语句继续编译而不变，并具有相同的语义。</p><h3 id="2-11-向量-API-的第六个孵化器"><a href="#2-11-向量-API-的第六个孵化器" class="headerlink" title="2.11 向量 API 的第六个孵化器"></a>2.11 向量 API 的第六个孵化器</h3><p>该 API 表达了在支持的 CPU 体系结构上可靠编译为优化向量指令的向量计算，其性能优于等效的标量计算。向量 API 此前在 JDK 16 至 JDK 20 中进行了孵化。这个最新版本包括性能增强和错误修复。该提案的目标包括清晰简洁，与平台无关，并在 x64 和 AArch64 体系结构上提供可靠的运行时编译和性能。其他目标包括在向量计算无法完全表示为向量指令序列时优雅降级。</p><h3 id="2-12-外部函数和内存-API-的第三次预览"><a href="#2-12-外部函数和内存-API-的第三次预览" class="headerlink" title="2.12 外部函数和内存 API 的第三次预览"></a>2.12 外部函数和内存 API 的第三次预览</h3><p>它使 Java 程序能够与 Java 运行时之外的代码和数据进行互操作。通过高效调用外部函数和安全访问外部内存，该 API 使 Java 程序能够调用本机库并处理本机数据，而无需使用 JNI (Java 本机接口) 的脆弱性和危险性。该 API 此前在 JDK 20 和 JDK 19 中进行了预览。JDK 21 预览中的改进包括带有新的元素来解引用地址布局的增强布局路径、Arena 接口中的本地段生命周期的集中管理、备用本机链接器实现以及 VaList 的删除。该提案的目标包括易用性、性能、通用性和安全性。它的目标不是在此 API 之上重新实现 JNI, 也不是以任何方式更改 JNI。</p><h3 id="2-13-虚拟线程"><a href="#2-13-虚拟线程" class="headerlink" title="2.13 虚拟线程"></a>2.13 虚拟线程</h3><p>是轻量级线程，它承诺大大减少编写、维护和观察高吞吐量并发应用程序的工作量。该计划的目标包括使按线程请求风格编写的服务器应用程序能够在接近最佳硬件利用率的情况下扩展，使使用 lang.Thread API 的现有代码通过最小更改采用虚拟线程，并使用当前 JDK 工具轻松调试和分析虚拟线程。虚拟线程在 JDK 20 和 JDK 19 中进行了预览，将在 JDK 21 中最终确定。在 JDK 21 中，虚拟线程现在始终支持线程本地变量，并使创建不具有这些变量的虚拟线程成为不可能。保证对线程本地变量的支持可以确保更多现有库可以不变地与虚拟线程一起使用，并帮助将面向任务的代码迁移到使用虚拟线程。</p><h3 id="2-14-序列集合"><a href="#2-14-序列集合" class="headerlink" title="2.14 序列集合"></a>2.14 序列集合</h3><p>提案引入了表示具有定义遭遇顺序的集合的接口。每个集合都有明确定义的第一个和第二个元素等，直到最后一个元素。提供了统一的 API 来接受第一个和最后一个元素并以相反顺序处理元素。该提案的动机是 Java 的集合框架缺少表示具有定义遭遇顺序的元素序列的集合类型。它还缺少适用于这些集合的统一操作集。这些缺陷一直是个问题和抱怨的来源。该提案要求为序列集合、集合和映射定义接口，并将这些接口 retrofit 到现有的集合类型层次结构中。所有这些新方法都有默认实现。</p><h3 id="2-15-字符串模板"><a href="#2-15-字符串模板" class="headerlink" title="2.15 字符串模板"></a>2.15 字符串模板</h3><p>JDK 21 中的预览功能，它通过将字面文本与嵌入式表达式和处理器结合来补充 Java 的现有字符串文本块，以产生特定结果。这种语言特性和 API 旨在通过使动态计算的值易于表示字符串来简化 Java 程序的编写。它有望增强表达式的可读性，提高程序安全性，保持灵活性，并简化使用以非 Java 语言编写的字符串的 API。启用从字面文本和嵌入式表达式组合派生非字符串表达式的开发也是一个目标。</p><p>与这些 JDK 增强提案分开，据 Oracle 的 Java 团队称，JDK 21 将更改 JDK 在 Windows 上为网络接口分配名称的方式。执行网络多播或使用 java.net.NetworkInterface API 的应用程序维护人员应注意此更改。</p><p>JDK 历史上为 Windows 上的网络接口合成名称。这已更改为使用 Windows 操作系统分配的名称。此更改可能会影响使用 NetworkInterface.GetbyName (String name) 方法查找网络接口的代码。JDK 21 还将在 JDK 飞行记录器中进行关键更改，包括使从命令行分析飞行记录更加容易。</p><p>作为 LTS 版本，JDK 21 将获得 5 年首要支持和直到 2031 年 9 月的延长支持。当前的 LTS 版本是在 2021 年 9 月发布的 JDK 17。非 LTS 版本 (如 JDK 20 和 JDK 19) 仅获得 6 个月的首要支持，没有延长支持。LTS 版本每两年发布一次。</p><p>参考</p><ul><li><a href="https://openjdk.org/projects/jdk/21/">JDK 21 </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> JDK21 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流浪在被资本定义的情感世界里</title>
      <link href="/post/%E6%B5%81%E6%B5%AA%E5%9C%A8%E8%A2%AB%E8%B5%84%E6%9C%AC%E5%AE%9A%E4%B9%89%E7%9A%84%E6%83%85%E6%84%9F%E4%B8%96%E7%95%8C%E9%87%8C.html"/>
      <url>/post/%E6%B5%81%E6%B5%AA%E5%9C%A8%E8%A2%AB%E8%B5%84%E6%9C%AC%E5%AE%9A%E4%B9%89%E7%9A%84%E6%83%85%E6%84%9F%E4%B8%96%E7%95%8C%E9%87%8C.html</url>
      
        <content type="html"><![CDATA[<p>​        在这个信息爆炸的时代，想联系谁一条消息就可以发送过去，我们为何还会感到孤独落寞，为什么呢?</p><p>​        以前车马很慢，一生只够爱一人，一封书信即使要等十天半月也丝毫不影响人们之间的感情，过年吃一顿带油水的饭也是幸福，所以油光满面便在当时象征着幸福。</p><p>​        反观现在，我们在这个被各种资本定义的世界里，被定义的爱情观里，一次次被消耗折磨…. </p><p>​        “不秒回vx就代表不在意”,“不给花钱就是不重视”,“爱她就送她DR钻戒”，听过一句话:“产品卖不出去怎么办，那与爱情捆绑挂钩”。其中最出名的例子就是钻石，后面便是数不尽的xx的第一杯奶茶，xx的第一份烤栗子，其实没有这些噱头，爱你的人在遇到这些东西的时候，或者遇到其他他们认为你喜欢的东西，也会记在心里找机会送你，靠主动而不是推动，所以我们一次次的把自己的感情带入到资本的圈套。</p><p>​        我们开始变得敏感…爱并没有那么复杂，真诚永远是必杀技，但前提是遇到对的人，否则只是一场空，可惜这个世界有太多人不真诚，他们只是需要一个”有对象”的名分，而不在乎这个人是谁，自然他们也不太需要投入太多，最后，负心人身经百战风生水起，痴心人却四处碰壁郁郁寡欢，只能四处流浪。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大厂都在用的Git管理规范</title>
      <link href="/post/%E5%A4%A7%E5%8E%82%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84Git%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83.html"/>
      <url>/post/%E5%A4%A7%E5%8E%82%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84Git%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83.html</url>
      
        <content type="html"><![CDATA[<h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>​    master 为主分支，也是用于部署生产环境的分支，需要确保 master 分支稳定性。master 分支一般由 release 以及 hotfix 分支合并，任何时间都不能直接修改代码。</p><h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><p>​    develop 为开发环境分支，始终保持最新完成以及 bug 修复后的代码，用于前后端联调。一般开发的新功能时，feature 分支都是基于 develop 分支创建的。</p><h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><p>​    开发新功能时，以 develop 为基础创建 feature 分支。</p><p>​    分支命名时以 <code>feature/</code> 开头，后面可以加上开发的功能模块， 命名示例：<code>feature/user_module</code>、<code>feature/cart_module</code></p><h3 id="test-分支"><a href="#test-分支" class="headerlink" title="test 分支"></a>test 分支</h3><p>​    test 为测试环境分支，外部用户无法访问，专门给测试人员使用，版本相对稳定。</p><h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><p>​    release 为预上线分支（预发布分支），UAT 测试阶段使用。一般由 test 或 hotfix 分支合并，不建议直接在 release 分支上直接修改代码。</p><h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><p>​    线上出现紧急问题时，需要及时修复，以 master 分支为基线，创建 hotfix 分支。修复完成后，需要合并到 master 分支和 develop 分支。</p><p>​    分支命名以 <code>hotfix/</code> 开头的为修复分支，它的命名规则与 feature 分支类似。</p><h2 id="分支与环境对应关系"><a href="#分支与环境对应关系" class="headerlink" title="分支与环境对应关系"></a>分支与环境对应关系</h2><p>​    在系统开发过程中常用的环境：</p><ul><li>DEV 环境（Development environment）：用于开发者调试使用</li><li>FAT 环境（Feature Acceptance Test environment）：功能验收测试环境，用于测试环境下的软件测试者测试使用</li><li>UAT 环境 （User Acceptance Test environment）：用户验收测试环境，用于生产环境下的软件测试者测试使用</li><li>PRO 环境（Production environment）：生产环境</li></ul><p>​    对应关系：</p><div class="table-container"><table><thead><tr><th style="text-align:left">分支</th><th style="text-align:left">功能</th><th style="text-align:left">环境</th><th style="text-align:left">可访问</th></tr></thead><tbody><tr><td style="text-align:left">master</td><td style="text-align:left">主分支，稳定版本</td><td style="text-align:left">PRO</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">develop</td><td style="text-align:left">开发分支，最新版本</td><td style="text-align:left">DEV</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">feature</td><td style="text-align:left">开发分支，实现新特性</td><td style="text-align:left"></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">测试分支，功能测试</td><td style="text-align:left">FAT</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">release</td><td style="text-align:left">预上线分支，发布新版本</td><td style="text-align:left">UAT</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">hotfix</td><td style="text-align:left">紧急修复分支，修复线上 bug</td><td style="text-align:left"></td><td style="text-align:left">否</td></tr></tbody></table></div><h3 id="分支合并流程规范"><a href="#分支合并流程规范" class="headerlink" title="分支合并流程规范"></a>分支合并流程规范</h3><p>​        业界常见的两大主分支（master、develop）、三个辅助分支（feature、release、hotfix）</p><p>我们团队在开发时，至少需要保证以下流程：</p><ul><li>develop 分支和 hotfix 分支，必须从 master 分支检出</li><li>由 develop 分支合并到 test 分支</li><li>功能测试无误后，由 test 分支合并到 release 分支</li><li>UAT 测试通过后，由 release 分支合并到 master 分支</li><li>对于工作量小的功能开发（工时小于 1 天），可以直接在 devolop 分支进行开发，否则由 develop 分支检出 feature 分支进行开发，开发完后合并到 develop 分支</li></ul><h2 id="Git-Commit-Message-规范"><a href="#Git-Commit-Message-规范" class="headerlink" title="Git Commit Message 规范"></a>Git Commit Message 规范</h2><p>​        Git commit message 规范指提交代码时编写的规范注释，编写良好的 Commit messages 可以达到 3 个重要的目的：</p><ul><li>加快代码 review 的流程</li><li>帮助我们编写良好的版本发布日志</li><li>让之后的维护者了解代码里出现特定变化和 feature 被添加的原因</li></ul><h3 id="Angular-Git-Commit-Guidelines"><a href="#Angular-Git-Commit-Guidelines" class="headerlink" title="Angular Git Commit Guidelines"></a>Angular Git Commit Guidelines</h3><p>​    业界应用的比较广泛的是 Angular Git Commit Guidelines：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><ul><li>type：提交类型</li><li>scope：可选项，本次 commit 波及的范围</li><li>subject：简明扼要的阐述下本次 commit 的主旨，在 <code>Angular Git Commit Guidelines</code> 中强调了三点。使用祈使句，首字母不要大写，结尾无需添加标点</li><li>body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机</li><li>footer: 描述下与之关联的 issue 或 break change</li></ul><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><p>​        项目中实际可以采用简易版规范：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;</span><br></pre></td></tr></table></figure><h3 id="type-规范"><a href="#type-规范" class="headerlink" title="type 规范"></a>type 规范</h3><p>​    <code>Angular Git Commit Guidelines</code> 中推荐的 type 类型如下：</p><ul><li>feat: 新增功能</li><li>fix: 修复 bug</li><li>docs: 仅文档更改</li><li>style: 不影响代码含义的更改（空白、格式设置、缺失 分号等）</li><li>refactor: 既不修复 bug 也不添加特性的代码更改</li><li>perf: 改进性能的代码更改</li><li>test: 添加缺少的测试或更正现有测试</li><li>chore: 对构建过程或辅助工具和库（如文档）的更改</li></ul><p>除此之外，还有一些常用的类型：</p><ul><li>delete：删除功能或文件</li><li>modify：修改功能</li><li>build：改变构建流程，新增依赖库、工具等（例如 webpack、gulp、npm 修改）</li><li>test：测试用例的新增、修改</li><li>ci：自动化流程配置修改</li><li><p>revert：回滚到上一个版本</p><h3 id="单次提交注意事项"><a href="#单次提交注意事项" class="headerlink" title="单次提交注意事项"></a>单次提交注意事项</h3></li><li><p>提交问题必须为同一类别</p></li><li>提交问题不要超过 3 个</li><li>提交的 commit 发现不符合规范，<code>git commit --amend -m &quot;新的提交信息&quot;</code> 或 <code>git reset --hard HEAD</code> 重新提交一次</li></ul><h2 id="配置-gitignore-文件"><a href="#配置-gitignore-文件" class="headerlink" title="配置.gitignore 文件"></a>配置.gitignore 文件</h2><p><code>.gitignore</code> 是一份用于忽略不必提交的文件的列表，项目中可以根据实际需求统一<code>.gitignore</code> 文件减少不必要的文件提交和冲突，净化代码库环境。</p><p>​    通用文件示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line">!**/src/main/**/build/</span><br><span class="line">!**/src/test/**/build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line">/logs*</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line">*.cmd</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>此外，还有一些其他建议：</p><ul><li>master 分支的每一次更新，都建议打 tag 添加标签，通常为对应版本号，便于管理</li><li>feature 分支、hotfix 分支在合并后可以删除，避免分支过多管理混乱</li><li>每次 pull 代码前，提交本地代码到本地库中，否则可能回出现合并代码出错，导致代码丢失</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> Git </tag>
            
            <tag> Git管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus的join联表查询</title>
      <link href="/post/MyBatisPlus%E7%9A%84join%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html"/>
      <url>/post/MyBatisPlus%E7%9A%84join%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，mybatis plus 封装的 mapper 不支持 join，如果需要支持就必须自己去实现。但是对于大部分的业务场景来说，都需要多表 join，要不然就没必要采用关系型数据库了。</p><p>那么有没有一种不通过硬 SQL 的形式，通过框架提供 join 能力呢？答案是，可以有。经过一段时间的插眼排眼操作，成功的封装了一个 jar 包。本文讲讲它的用法。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>Maven</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-join&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>Gradle</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.yulichang:mybatis-plus-join:1.2.4&#x27;</span></span><br></pre></td></tr></table></figure><p>或者 clone 代码到本地执行 mvn install，再引入以上依赖。</p><p>注意：mybatis plus version &gt;= 3.4.0。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>mapper 继承 MPJBaseMapper (必选)</li><li>service 继承 MPJBaseService (可选)</li><li>serviceImpl 继承 MPJBaseServiceImpl (可选)</li></ul><h2 id="核心类-MPJLambdaWrapper-和-MPJQueryWrapper"><a href="#核心类-MPJLambdaWrapper-和-MPJQueryWrapper" class="headerlink" title="核心类 MPJLambdaWrapper 和 MPJQueryWrapper"></a>核心类 MPJLambdaWrapper 和 MPJQueryWrapper</h2><h3 id="MPJLambdaWrapper-用法"><a href="#MPJLambdaWrapper-用法" class="headerlink" title="MPJLambdaWrapper 用法"></a>MPJLambdaWrapper 用法</h3><h4 id="简单的三表查询"><a href="#简单的三表查询" class="headerlink" title="简单的三表查询"></a>简单的三表查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJLambdaWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(UserAddressDO::getTel)</span><br><span class="line">                        .selectAs(UserAddressDO::getAddress, UserDTO::getUserAddress)</span><br><span class="line">                        .select(AreaDO::getProvince, AreaDO::getCity)</span><br><span class="line">                        .leftJoin(UserAddressDO.class, UserAddressDO::getUserId, UserDO::getId)</span><br><span class="line">                        .leftJoin(AreaDO.class, AreaDO::getId, UserAddressDO::getAreaId)</span><br><span class="line">                        .eq(UserDO::getId, <span class="number">1</span>)</span><br><span class="line">                        .like(UserAddressDO::getTel, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .gt(UserDO::getId, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    t1.tel,</span><br><span class="line">    t1.address <span class="keyword">AS</span> userAddress,</span><br><span class="line">    t2.province,</span><br><span class="line">    t2.city </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t </span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address t1 <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t.id </span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> area t2 <span class="keyword">ON</span> t2.id <span class="operator">=</span> t1.area_id </span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    t.id <span class="operator">=</span> ? </span><br><span class="line">    <span class="keyword">AND</span> t1.tel <span class="keyword">LIKE</span> ? </span><br><span class="line">    <span class="keyword">AND</span> t.id <span class="operator">&gt;</span> ?)</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>UserDTO.class 查询结果返回类 (resultType)</li><li>selectAll () 查询指定实体类的全部字段</li><li>select () 查询指定的字段，支持可变参数，同一个 select 只能查询相同表的字段 故将 UserAddressDO 和 AreaDO 分开为两个 select ()</li><li>selectAs () 字段别名查询，用于数据库字段与业务实体类属性名不一致时使用</li><li>leftJoin () 参数说明 第一个参数：参与连表的实体类 class 第二个参数：连表的 ON 字段，这个属性必须是第一个参数实体类的属性 第三个参数：参与连表的 ON 的另一个实体类属性</li><li>默认主表别名是 t, 其他的表别名以先后调用的顺序使用 t1,t2,t3….</li><li>条件查询，可以查询主表以及参与连接的所有表的字段，全部调用 mp 原生的方法，正常使用没有 sql 注入风险</li></ul><p>MPJLambdaWrapper 还有很多其他的功能</p><ul><li>简单的 SQL 函数使用：<code>https://gitee.com/best_handsome/mybatis-plus-join/wikis/selectFunc()?sort_id=4082479</code></li><li>ON 语句多条件支持：<code>https://gitee.com/best_handsome/mybatis-plus-join/wikis/leftJoin?sort_id=3496671</code></li></ul><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        IPage&lt;UserDTO&gt; iPage = userMapper.selectJoinPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">10</span>), UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJLambdaWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(UserAddressDO::getTel)</span><br><span class="line">                        .selectAs(UserAddressDO::getAddress, UserDTO::getUserAddress)</span><br><span class="line">                        .select(AreaDO::getProvince, AreaDO::getCity)</span><br><span class="line">                        .leftJoin(UserAddressDO.class, UserAddressDO::getUserId, UserDO::getId)</span><br><span class="line">                        .leftJoin(AreaDO.class, AreaDO::getId, UserAddressDO::getAreaId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    t1.tel,</span><br><span class="line">    t1.address <span class="keyword">AS</span> userAddress,</span><br><span class="line">    t2.province,</span><br><span class="line">    t2.city</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address t1 <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t.id</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> area t2 <span class="keyword">ON</span> t2.id <span class="operator">=</span> t1.area_id</span><br><span class="line">LIMIT ?,?</span><br></pre></td></tr></table></figure><h3 id="MPJQueryWrapper"><a href="#MPJQueryWrapper" class="headerlink" title="MPJQueryWrapper"></a>MPJQueryWrapper</h3><h4 id="简单的-3-表查询"><a href="#简单的-3-表查询" class="headerlink" title="简单的 3 表查询"></a>简单的 3 表查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>, <span class="string">&quot;a.province&quot;</span>)</span><br><span class="line">                        .leftJoin(<span class="string">&quot;user_address addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>)</span><br><span class="line">                        .like(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .le(<span class="string">&quot;a.province&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    a.province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    addr.tel <span class="keyword">LIKE</span> ?</span><br><span class="line">    <span class="keyword">AND</span> a.province <span class="operator">&lt;=</span> ?)</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>UserDTO.class 查询结果类 (resultType)</li><li>selectAll (UserDO.class) 查询主表全部字段 (主表实体类) 默认主表别名 “t”</li><li>select () mp 的 select 策略是覆盖，以最后一次为准，这里的策略是追加，可以一直 select 主表字段可以用 lambda, 会自动添加表别名，主表别名默认是 t , 非主表字段必须带别名查询</li><li>leftJoin () rightJoin () innerJoin () 传 sql 片段 格式 (表 + 别名 + 关联条件)</li><li>条件查询，可以查询主表以及参与连接的所有表的字段，全部调用 mp 原生的方法，正常使用没有 sql 注入风险</li></ul><h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        IPage&lt;UserDTO&gt; page = userMapper.selectJoinPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>), UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>)</span><br><span class="line">                        .select(<span class="string">&quot;a.province&quot;</span>)</span><br><span class="line">                        .leftJoin(<span class="string">&quot;user_address addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    a.province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id </span><br><span class="line">LIMIT ?,?</span><br></pre></td></tr></table></figure><h4 id="还可以这么操作，但不建议"><a href="#还可以这么操作，但不建议" class="headerlink" title="还可以这么操作，但不建议"></a>还可以这么操作，但不建议</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>)</span><br><span class="line">                        <span class="comment">//行列转换</span></span><br><span class="line">                        .select(<span class="string">&quot;CASE t.sex WHEN &#x27;男&#x27; THEN &#x27;1&#x27; ELSE &#x27;0&#x27; END AS sex&quot;</span>)</span><br><span class="line">                        <span class="comment">//求和函数</span></span><br><span class="line">                        .select(<span class="string">&quot;sum(a.province) AS province&quot;</span>)</span><br><span class="line">                        <span class="comment">//自定义数据集</span></span><br><span class="line">                        .leftJoin(<span class="string">&quot;(select * from user_address) addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>)</span><br><span class="line">                        .like(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .le(<span class="string">&quot;a.province&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .orderByDesc(<span class="string">&quot;addr.id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    <span class="keyword">CASE</span> t.sex <span class="keyword">WHEN</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> sex,</span><br><span class="line">    <span class="built_in">sum</span>(a.province) <span class="keyword">AS</span> province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_address) addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    addr.tel <span class="keyword">LIKE</span> ?</span><br><span class="line">    <span class="keyword">AND</span> a.province <span class="operator">&lt;=</span> ?)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    addr.id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>针对以上 jar 感兴趣的，可以下载对应的源码，进一步的学习！</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis Plus Join </tag>
            
            <tag> MyBatis Plus </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 速查表：必备的 12 个 Git 命令</title>
      <link href="/post/Git%20%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%9A%E5%BF%85%E5%A4%87%E7%9A%84%2012%20%E4%B8%AA%20Git%20%E5%91%BD%E4%BB%A4.html"/>
      <url>/post/Git%20%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%9A%E5%BF%85%E5%A4%87%E7%9A%84%2012%20%E4%B8%AA%20Git%20%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然在使用 Git 的最基本级别时不需要这些中级命令，但它们可以帮助用户提高使用 Git 的效率。它们提供了一组强大的功能，可以帮助您成为一个全面发展的开发者，这通常意味着能够以创造性的方式解决问题。</p></blockquote><p>在本篇文章中，我们将介绍必备的 12 个 Git 命令。</p><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>git config 命令用于设置 Git 配置。使用这个命令，用户可以在三个不同级别设置配置：</p><ul><li>本地级别：在特定的 Git 仓库中（存储在项目根目录的 .git/config 文件中）。</li><li>全局级别：针对操作系统中的当前用户。</li><li>系统级别：针对操作系统中的所有用户。</li></ul><p>默认情况下，git config 命令会更改本地级别的设置。此命令可用于设置诸如 Git 用户名、电子邮件地址、默认文本编辑器（如 Vim）、默认合并行为、终端输出外观和别名等信息。</p><p>例如，可以使用以下命令设置当前用户的名称和电子邮件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git config <span class="comment">--global user.name &quot;Your Name&quot;</span></span><br><span class="line">git config <span class="comment">--global user.email &quot;name@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>可以使用以下命令将 Git 的默认文本编辑器设置为 Vim：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git config <span class="comment">--global core.editor &quot;vim&quot;</span></span><br></pre></td></tr></table></figure><p>列出所有当前 Git 的配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git config <span class="comment">--list --show-origin</span></span><br></pre></td></tr></table></figure><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>git mv 命令用于在 Git 仓库中移动和 / 或重命名文件。该命令会在工作目录中移动文件，并更新 Git 索引中旧文件路径和新文件路径。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git mv path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>old_file_name.ext path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>new_file_name.ext</span><br></pre></td></tr></table></figure><p>需要注意的是，文件在您的文件系统中也会被重命名 / 移动，所以这个命令一举两得。然而，旧文件的历史记录都被 Git 跟踪了，所以如果您发现需要旧版本，可以随时找回。</p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>git rm 命令用于从 Git 仓库中删除文件。它会在工作目录中删除文件，并从 Git 索引中移除文件。</p><p>要删除特定文件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git rm path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>filename.ext</span><br></pre></td></tr></table></figure><p>需要注意的是，此命令会从您的文件系统中删除文件。然而，已删除文件的历史记录仍被 Git 跟踪，所以如果您后来发现需要它，可以随时找回。</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff 命令用于显示提交、分支以及其他代码状态之间的差异。默认情况下，git diff 显示工作树与暂存区之间的差异。</p><p>该命令还可用于比较分支之间的差异：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git diff branch1 branch2</span><br></pre></td></tr></table></figure><p>或者用于比较两个提交之间的差异：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git diff commitID1 commitID2</span><br></pre></td></tr></table></figure><p>为了比较一个特定文件，也可以加上第三个文件名参数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git diff commitID1 commitID2 file_to_compare.ext</span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>git reset 命令用于将分支恢复到先前的状态。当给出提交、分支或其他引用时，该命令将分支和 HEAD 引用移动到指向该引用的位置。如果未提供引用参数，则默认将引用指向 HEAD。</p><p>该命令提供了三种操作模式：soft, mixed，和 hard。使用 soft 选项时，索引会被更新，但暂存的提交和工作目录保持不变。使用 mixed 选项（默认选项）时，索引将被重置，已暂存的更改将被移回工作目录。使用 hard 选项时，索引和工作目录都会被重置，所有更改都将丢失。</p><p>要将暂存区重置为与最近的提交匹配，而不丢失工作区的任何数据，请使用以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><p>撤销所有当前的更改并将工作区重置为与最近的提交匹配，请使用以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git reset <span class="comment">--hard</span></span><br></pre></td></tr></table></figure><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>git tag 命令用于创建一个人类可读的标签（例如版本号），用于引用存储库中特定的提交。标签在本质上是一个引用，类似于分支名称，但标签通常是静态的，因为它们指向单个提交，而分支名称是动态的，因为它们跟踪分支的末端，并随着新的提交添加而更新。通常情况下，标签在标记发布版本时很有用。</p><p>为当前签出的 Git 提交创建一个标记：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git tag tag_name</span><br></pre></td></tr></table></figure><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>Git rebase 命令允许用户将一系列提交移动到一个新的基础提交上。如果用户提供了一个引用参数，则该分支将在该分支上进行 rebase。否则，默认情况下，该分支将在远程分支上进行 rebase。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git rebase origin</span><br></pre></td></tr></table></figure><p>通过在 rebase 命令中添加 -i 选项，用户可以执行交互式 rebase。在交互式 rebase 中，用户还可以组合、拆分、重新排序、删除和编辑提交记录。</p><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>git cherry-pick 命令接受一个或多个提交记录，并将它们应用到一个现有的分支上。该命令提供了一种快速将提交记录添加到多个分支的方式，而无需执行 rebase 操作。</p><p>要将单个提交记录选取并应用到当前分支上，可以执行以下操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git cherry<span class="operator">-</span>pick commitID</span><br></pre></td></tr></table></figure><p>用户也可以选取一系列提交记录并将它们应用到分支上。默认情况下，cherry-pick 不包含第一个提交记录，但会包含最后一个提交记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git cherry<span class="operator">-</span>pick oldest_commit...newest_commit</span><br></pre></td></tr></table></figure><p>要让 cherry-pick 命令包含第一个和最后一个提交记录，可以将命令更新如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git cherry<span class="operator">-</span>pick oldest_commit<span class="operator">^</span>...newest_commit</span><br></pre></td></tr></table></figure><h2 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h2><p>git bisect 命令用于通过对提交历史记录进行二分查找来分离出特定的提交记录。该命令在帮助我们找出是哪个提交引入了 bug 时非常有用。</p><p>要运行这个命令，需要先找到一个问题未发生的过去提交记录，这里称之为 “good_commit_id”。然后在最近的分支上运行以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git bisect <span class="keyword">start</span></span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good good_commit_id</span><br></pre></td></tr></table></figure><p>Git 会对提交记录进行二分查找，它会检查当前提交和上一个好的提交之间的提交记录。此时，开发人员需要检查或测试代码，以确定 bug 是否仍然存在。如果 bug 仍然存在，则运行 git bisect bad 命令；如果 bug 不存在，则运行 git bisect good 命令。</p><p>一旦找到了引入 bug 的提交记录，搜索就会返回第一个坏的提交记录的 commit ID。从这里开始，用户可以检查引入 bug 的提交记录。然后可以使用 git bisect reset 命令将分支恢复到执行搜索之前的状态。</p><p>这为开发人员快速追踪 bug 的源头提供了一种方法，因为每次将提交历史记录分成两半，可以指数级地减少需要手动检查的提交记录数量。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>git revert 命令用于撤消之前提交的更改。该命令接受一个 commit ID，然后在当前分支上创建一个新的提交记录，以反转 revert 提交记录中的更改。这种方法允许用户撤消一个更改，而无需重写历史记录。执行该命令将在分支的末尾产生一个新的提交记录，用于撤消 revert 的提交记录中的更改。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git revert commitID</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>git fetch 命令用于从远程仓库下载引用（包括标签和分支）。它会下载新创建的引用，并完成本地已存储引用的历史记录。与 git pull 不同，git fetch 命令不会更新本地仓库的工作状态，也不会执行合并操作。默认情况下，git fetch 命令会获取当前仓库的所有引用。</p><p>要从远程仓库获取所有引用，请使用以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> origin</span><br></pre></td></tr></table></figure><p>要从特定分支获取引用，请使用以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> origin branch_name</span><br></pre></td></tr></table></figure><h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p>通过 git blame 命令，用户可以查看文件中每一行最后一次修改的时间以及进行修改的责任人。该工具对于理解文件的历史记录非常有用，可以帮助用户确定在代码更改方面应该向谁寻求问题或建议。</p><p>要查看特定文件的此信息，请使用以下命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git blame path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>filename.ext</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然在使用 Git 的最基本级别时不需要这些中级命令，但它们可以帮助用户提高使用 Git 的效率。它们提供了一组强大的功能，可以帮助您成为一个全面发展的开发者，这通常意味着能够以创造性的方式解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> Git知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 命令 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日随想</title>
      <link href="/post/%E4%BB%8A%E6%97%A5%E9%9A%8F%E6%83%B3.html"/>
      <url>/post/%E4%BB%8A%E6%97%A5%E9%9A%8F%E6%83%B3.html</url>
      
        <content type="html"><![CDATA[<h2 id="那天早上的雾散了，不止早上，不止雾"><a href="#那天早上的雾散了，不止早上，不止雾" class="headerlink" title="那天早上的雾散了，不止早上，不止雾"></a>那天早上的雾散了，不止早上，不止雾</h2><span id="more"></span><p>如果不是在一种理想中来考察我的生活，那么生活的平庸将使我痛苦不堪。<br>而在我怀有这种念头的时候，我们碰见了，你走进了我的生活，你是我最优雅的朋友，这并不困难，因为一看到你我就知道了，你和我站在世界的同一边。<br>更何况，我们还有那一次彻夜的长谈。<br>但是，我们的关系里拥有不纯之处，它不能以愉快和不愉快而论，我只想生活得强烈一些，这个态度在你和我的关系里再明显不过了。<br>因为有些时候，情况显然是我把自己的心意强加于你了。<br>欲望受到侵蚀，行动定要受阻，就是在爱情里我也体会到这一点，根本不存在出路，只存在幻想，幻想一这致命的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
